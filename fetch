#!/usr/bin/env bash
# Fetch info about your system
#
# Original by Dylan Araps
# https://github.com/dylanaraps/dotfiles/
# Created by Ethan Chan
# https://github.com/metakirby5/dotfiles/

# Config file to source
# Can contain:
#   FETCH_TITLE=text
#   FETCH_UNDERLINE=text
#   FETCH_PRIMARY_N=0-7
#   FETCH_SECONDARY_N=0-7
#   FETCH_CHARHEIGHT=number
#   FETCH_CHARWIDTH=number
#   FETCH_ADDITIONAL_PADDING=number
#   FETCH_IMGDIR=/some/path/
#
#   # Info MUST be defined in this way!
#   # You will need to escape backslashes.
#   # It will be eval'd later, so be careful...
#   # Format: ["position:title"]="info"
#   # Any title without a position is alphabetically ordered afterwards.
#   read -d '' FETCH_INFO <<"EOF"
#     declare -A info=(
#       ["1:OS"]="$(cat /etc/*ease | awk -F= '/^NAME=/{ print $2 }')"
#       ["2:Kernel"]="$(uname -r)"
#       ["3:Uptime"]="$(uptime -p | sed 's/ou\|ute//g')"
#       # etc.
#     )
#   EOF

fetch_config=~/.config/fetch/config

# === DO NOT EDIT BELOW THIS LINE ===

usage() {
  echo "USAGE: $(basename "$0") [-h] [-i] [-r] [-f FUZZ]"
  echo "  -h              help"
  echo "  -i IMG_SRC      image source"
  echo "  -r              remake image"
  echo "  -f FUZZ         fuzz to use in image creation"
  exit 1
}

[ -f "$fetch_config" ] && source "$fetch_config"

# Parse args
while getopts ":hi:rf:" opt; do
  case $opt in
    h) usage ;;
    i) img_src="$OPTARG" ;;
    r) remake_img=1 ;;
    f) fuzz="$OPTARG" ;;
    \?) echo "Invalid option: -$OPTARG" >&2; usage ;;
    :) echo "Option -$OPTARG requires an argument." >&2; usage ;;
  esac
done

# Defaults
title="${FETCH_TITLE:="$(whoami)"}"
underline="${FETCH_UNDERLINE:="$(printf "%${#title}s" | tr ' ' '=')="}"
primary_n="${FETCH_PRIMARY_N:=1}"
secondary_n="${FETCH_SECONDARY_N:=4}"
charheight="${FETCH_CHARHEIGHT:=31}"
charwidth="${FETCH_CHARWIDTH:="$(($charheight / 2))"}"
additional_padding="${FETCH_ADDITIONAL_PADDING:=2}"
imgdir="${FETCH_IMGDIR:="$HOME/.fetch_crops/"}"

img_src="${img_src:="$(cat ~/.fehbg | cut -d\' -f2)"}"
fuzz="${fuzz:=15%}"

# Handle the array specially
eval "$FETCH_INFO"
[ -z "${info[*]}" ] && declare -A info=(
  ["1:OS"]="$(cat /etc/*ease | awk -F= '/^NAME=/{ print $2 }')"
  ["2:Kernel"]="$(uname -r)"
  ["3:Uptime"]="$(uptime -p | sed 's/ou\|ute//g')"
  ["4:Shell"]="$(basename "$SHELL")"
  ["5:Window Manager"]="$(wmctrl -m | awk '/^Name:/{ print $2}')"
  ["6:CPU"]="$(cat /proc/cpuinfo |\
    awk -F: '/^model name/{ gsub(/^\s+/, "", $2); print $2; exit }')"
  ["7:Speed"]="$(lscpu |\
    awk -F: '/^CPU MHz:/{ print "scale=1;" $2 "/ 1000" }' | bc -l)GHz"
  ["8:Memory"]="$(free -m | awk '/^Mem:/{ print $3 "/" $2 " MB" }')"
)

# Colors
primary="$(tput setaf $primary_n)"
secondary="$(tput setaf $secondary_n)"
black="$(tput setaf 0)"
bold="$(tput bold)"
clear="$(tput sgr0)"

put_color_header() {
  local text
  for i in `seq 0 7`; do
    case "$i" in
      "$primary_n")     text=' .. ' ;;
      "$secondary_n")   text=' __ ' ;;
      *)                text='    ' ;;
    esac

    echo -n "$(tput setaf $i)$bold$text$clear "
  done
}

put_colors() {
  for i in `seq $1 $2`; do
    echo -n "$(tput setab $i)    $clear "
  done
}

# Calculate sizing info
numlines="$((${#info[@]} + 5))" # title + underline + 3x color info = 5
isize="$(($numlines * $charheight))"
padlen="$(($isize / $charwidth + $additional_padding))"
linelen="$(($(tput cols) - $padlen))"
pad="$(printf "%${padlen}s")"

# Prepare the image
img="${imgdir%/}/$(basename $img_src)"
if [ ! -f "$img" ] || [ ! -z "$remake_img" ]; then
  if [ ! -d "$imgdir" ]; then
    mkdir "$imgdir" || exit "$?"
  fi

  # Trim
  convert "$img_src" -crop "$(convert "$img_src" \
    -fuzz "$fuzz" -trim -format '%wx%h%O' info: 2>/dev/null)" \
    +repage "$img" &>/dev/null

  wsize="$(identify -format '%[fx:min(w,h)]' "$img" 2>/dev/null)"
  mogrify -crop "$wsize"x"$wsize"+0+0 -gravity center "$img" &>/dev/null

  if [ ! -f "$img" ]; then
    echo "Image \"$img_src\" not fond!"
    exit 1
  fi
fi

# Order and format the info
ordered=''
unordered=''
tab="$(printf '\t')" # We use this to separate the key

for k in "${!info[@]}"; do
  cur="$bold$secondary${k#*:}$clear: ${info[$k]}"

  # Do some truncation
  len="$(echo -n "${k#*:}: ${info[$k]}" | wc -c)"
  invis_len="$(($(echo -n "$cur" | wc -c) - $len))"
  [ "$len" -gt "$linelen" ] &&\
    cur="$(echo "$cur" | cut -c-$(($linelen + $invis_len - 2)))â€¦"

  cur="$pad$cur"

  # Add to ordered or unordered
  if [[ "$k" == *:* ]]; then
    ordered="$ordered
$priority${k%%:*}$tab$cur"
  else
    unordered="$unordered
$cur"
  fi
done

# Sort the ordered info, and concatenate it to unordered to make output
output="$(echo "$ordered" | sort -n | tail -n+2 | sed "s/^.\+$tab//")"
output="$output$(echo "$unordered" | sort -d)"

# Print info
clear
tput civis
echo "$pad$bold$primary$title$clear"
echo "$pad$bold$black$underline"
echo "$output"
echo "$pad$(put_color_header)"
echo "$pad$(put_colors 0 7)"
echo "$pad$(put_colors 8 15)"
printf "0;1;$xoffset;$yoffset;$isize;$isize;;;;;$img\n4;\n3;" |\
  /usr/lib/w3m/w3mimgdisplay
tput cnorm

