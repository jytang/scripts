#!/usr/bin/env bash
# Fetch info about your system
#
# Original by Dylan Araps
# https://github.com/dylanaraps/dotfiles/
# Created by Ethan Chan
# https://github.com/metakirby5/dotfiles/

# Config file to source
# Can contain:
#   TITLE=text
#   UNDERLINE=text
#   PRIMARY_N=0-7
#   SECONDARY_N=0-7
#   IMGSRC=/path/to/img
#   IMGTEMPDIR=/some/temp/path
#   CHARHEIGHT=number
#   ADDITIONAL_PADDING=number
#
#   # Info MUST be defined in this way!
#   # It will be eval'd later, so be careful...
#   # Format: ["position:title"]="info"
#   # Any title without a position is alphabetically ordered afterwards.
#   read -d '' INFO <<"EOF"
#     declare -A info=(
#       ["1:OS"]="$(cat /etc/*ease | awk -F= '/^NAME=/{ print $2 }')"
#       ["2:Kernel"]="$(uname -r)"
#       ["3:Uptime"]="$(uptime -p | sed 's/ou\|ute//g')"
#       # etc.
#     )
#   EOF

fetch_config=~/.config/fetch/config

# === DO NOT EDIT BELOW THIS LINE ===

[ -f "$fetch_config" ] && source "$fetch_config"

# Defaults
title="${TITLE:="$(whoami)"}"
underline="${UNDERLINE:="$(printf "%${#title}s" | tr ' ' '=')="}"
primary_n="${PRIMARY_N:=1}"
secondary_n="${SECONDARY_N:=4}"
imgsrc="${IMGSRC:="$(cat ~/.fehbg | cut -d\' -f2)"}"
imgtempdir="${IMGTEMPDIR:=/tmp/fetch/}"
charheight="${CHARHEIGHT:=31}"
charwidth="${CHARWIDTH:="$(($charheight / 2))"}"
additional_padding="${ADDITIONAL_PADDING:=3}"

# Handle the array specially
eval "$INFO"
[ -z "${info[*]}" ] && declare -A info=(
  ["1:OS"]="$(cat /etc/*ease | awk -F= '/^NAME=/{ print $2 }')"
  ["2:Kernel"]="$(uname -r)"
  ["3:Uptime"]="$(uptime -p | sed 's/ou\|ute//g')"
  ["4:Shell"]="$SHELL"
  ["5:Window Manager"]="$(wmctrl -m | awk '/^Name:/{ print $2}')"
  ["6:CPU"]="$(cat /proc/cpuinfo |\
  awk -F: '/^model name/ { print $2; exit }')"
  ["7:Speed"]="$(lscpu |\
  awk -F: '/^CPU MHz:/ { print "scale=1;" $2 "/ 1000" }' | bc -l)GHz"
  ["8:Memory"]="$(free -m | awk '/^Mem:/ { print $3 "/" $2 " MB" }')"
)

# Colors
primary="$(tput setaf $primary_n)"
secondary="$(tput setaf $secondary_n)"
black="$(tput setaf 0)"
bold="$(tput bold)"
clear="$(tput sgr0)"

put_color_header() {
  local text
  for i in `seq 0 7`; do
    case "$i" in
      "$primary_n")     text=' .. ' ;;
      "$secondary_n")   text=' __ ' ;;
      *)                text='    ' ;;
    esac

    echo -n "$(tput setaf $i)$bold$text$clear "
  done
}

put_colors() {
  for i in `seq $1 $2`; do
    echo -n "$(tput setab $i)    $clear "
  done
}

# Calculate sizing info
numlines="$((${#info[@]} + 5))" # title + underline + 3x color info = 5
isize="$(($numlines * $charheight))"
pad="$(printf "%$(($isize / $charwidth + 2))s")" # +2 for padding

# Prepare the image
img="$imgtempdir/$(basename $imgsrc)"
if [ ! -f "$img" ]; then
  [ ! -d "$imgtempdir" ] && (mkdir "$imgtempdir" || exit)
  wsize="$(identify -format '%h' $imgsrc 2>/dev/null)"
  convert "$imgsrc" -crop "$wsize"x"$wsize"+0+0 -gravity center "$img" \
    &>/dev/null
fi

# Order and format the info
ordered=''
unordered=''
tab="$(printf '\t')" # We use this to separate the key

for k in "${!info[@]}"; do
  cur="$pad$bold$secondary${k#*:}$clear: ${info[$k]}"

  # Add to ordered or unordered
  if [[ "$k" == *:* ]]; then
    ordered="$ordered
$priority${k%%:*}$tab$cur"
  else
    unordered="$unordered
$cur"
  fi
done

# Sort the ordered info, and concatenate it to unordered to make output
output="$(echo "$ordered" | sort -n | tail -n+2 | sed "s/^.\+$tab//")"
output="$output$(echo "$unordered" | sort -d)"

# Print info
clear
tput civis
echo "$pad$bold$primary$title$clear"
echo "$pad$bold$black$underline"
echo "$output"
echo "$pad$(put_color_header)"
echo "$pad$(put_colors 0 7)"
echo "$pad$(put_colors 8 15)"
printf "0;1;$xoffset;$yoffset;$isize;$isize;;;;;$img\n4;\n3;" |\
  /usr/lib/w3m/w3mimgdisplay
tput cnorm

