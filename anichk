#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK

"""
Uses the (undocumented) hummingbird.me API and (undocumented) anichart.net API
to tell you what episodes you need to catch up on. You can specify the
username either via argument or the ANICHK_USERNAME environment variable.
"""

import re
import json
from sys import exit
from os import environ
from subprocess import check_output
from datetime import datetime, timedelta
from humanize import naturaltime
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from argcomplete import autocomplete

# Constants and helpers
HB_URL = ('https://hummingbird.me/library_entries'
          '?status=Currently+Watching&user_id={}')
AC_URL = 'http://anichart.net/api/chart/airing'
END = '\033[0m'
LONG_VOWELS = re.compile(r'([aeiou])\1+')


def normalize(s):
    return LONG_VOWELS.sub(r'\1', ''.join(c.lower() for c in s if c.isalnum()))


def red(s):
    return '\033[31m{}{}'.format(s, END)


def green(s):
    return '\033[32m{}{}'.format(s, END)


def yellow(s):
    return '\033[33m{}{}'.format(s, END)


def exit_with(s):
    print('{}\n'.format(red(s)))
    exit(1)


# Parse args
parser = ArgumentParser(description=__doc__,
                        formatter_class=RawDescriptionHelpFormatter)
parser.add_argument('--porcelain',
                    help="only output unwatched as [series] [episode #]",
                    action='store_true')
parser.add_argument('username',
                    help="hummingbird.me username",
                    nargs='?',
                    type=str,
                    default=environ.get('ANICHK_USERNAME'))
autocomplete(parser)
args = parser.parse_args()
porcelain = args.porcelain
username = args.username

if not username:
    exit_with("No username provided.")


# Printing functions
def human(s=''):
    if not porcelain:
        print(s.encode('UTF-8'))


def machine(s=''):
    if porcelain:
        print(s.encode('UTF-8'))


# For some reason, hummingbird.me doesn't like Python, so use curl.
def curl(url):
    return json.loads(check_output(['curl', '-sf', url]))


# Get your currently watching anime
human('Fetching hummingbird.me profile for {}...'.format(username))
try:
    hb = curl(HB_URL.format(username))
except OSError:
    exit_with("Could not reach hummingbird.me.")
except ValueError:
    exit_with("{} isn't on hummingbird.me.".format(username))
if not hb['library_entries']:
    exit_with("{} isn't watching anything.".format(username))

by_id = {
    a['id']: a
    for a in hb['anime']
}

# Get currently airing anime
human('Fetching currently airing series from anichart.net...')
try:
    ac = curl(AC_URL)
except OSError:
    exit_with("Could not reach anichart.net.")
except ValueError:
    exit_with("Malformed anichart.net JSON.")

airing = {}
for a in ac:
    airing[normalize(a['title_romaji'])] = a['airing']
    # Sometimes hummingbird.me will put english for romaji...
    airing[normalize(a['title_eng'])] = a['airing']

# Create list of series
anime = []
for info in hb['library_entries']:
    info.update(by_id[info['anime_id']])
    # For currently airing shows, pull in next episode info
    info.update(airing.get(normalize(info['romaji_title']), {}))
    anime.append(info)
anime.sort(key=lambda i: i['canonical_title'])

# Print info
human()
for a in anime:
    title = a['canonical_title']
    cur = a['episodes_watched']
    total = a['episode_count']

    try:
        available = a['next_episode'] - 1
    except KeyError:
        available = total

    # Only bother if we haven't finished the series
    if not total or cur < total:
        # If we're waiting for next episode
        if cur == available:
            # Create human-readable countdown
            try:
                time = naturaltime(
                    datetime.now() + timedelta(seconds=a['countdown'])
                ).replace(
                    ' from now', ''
                ).replace(
                    'hour', 'hr'
                ).replace(
                    'minute', 'min'
                ).replace(
                    'second', 'sec'
                )
            # Unknown time
            except KeyError:
                time = 'UNKNOWN'
            status = green(time)
        # If we're behind
        elif cur < available:
            status = yellow('{}/{}'.format(cur, available))
            machine(u'{} {}'.format(title, cur + 1))
        # If no information available
        elif not available:
            status = yellow('NO INFO')
        # Invalid state
        else:
            status = red('INVALID')
    # We need to mark this as complete
    else:
        status = red('COMPLTE')

    # Status must be colored to be padded correctly
    human(u'{:>16} {}'.format(status, title))
human()
