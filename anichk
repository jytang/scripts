#!/usr/bin/env python

"""
Uses the (undocumented) hummingbird.me API and (undocumented) anichart.net API
to tell you what episodes you need to catch up on. You can specify the
username either via argument or the ANICHK_USERNAME environment variable.
"""

import requests
from sys import exit
from os import environ
from datetime import datetime, timedelta
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from humanize import naturaltime

# Constants and helpers
HB_URL = ('https://hummingbird.me/library_entries'
          '?status=Currently+Watching&user_id={}')
AC_URL = 'http://anichart.net/api/chart/airing'
END = '\033[0m'

to_cmp = lambda s: ''.join(c.lower() for c in s if c.isalnum())
red = lambda s: '\033[31m{}{}'.format(s, END)
green = lambda s: '\033[32m{}{}'.format(s,END)
yellow = lambda s: '\033[33m{}{}'.format(s, END)
def exit_with(s):
    print('{}\n'.format(red(s)))
    exit(1)

# Parse args
parser = ArgumentParser(description=__doc__,
                        formatter_class=RawDescriptionHelpFormatter)
parser.add_argument('username',
                    help="hummingbird.me username",
                    nargs='?',
                    type=str)
username = parser.parse_args().username or environ.get('ANICHK_USERNAME')
if not username:
    exit_with("No username provided.")

# Get your currently watching anime
print('Fetching hummingbird.me profile for {}...'.format(username))
try:
    hb = requests.get(HB_URL.format(username)).json()
except requests.exceptions.ConnectionError:
    exit_with("Could not reach hummingbird.me.")
except ValueError:
    exit_with("{} isn't on hummingbird.me.".format(username))
if not hb['library_entries']:
    exit_with("{} isn't watching anything.".format(username))

by_id = {
    a['id']: a
    for a in hb['anime']
}

# Get currently airing anime
print('Fetching currently airing series from anichart.net...')
try:
    ac = requests.get(AC_URL).json()
except requests.exceptions.ConnectionError:
    exit_with("Could not reach anichart.net.")

airing = {
    to_cmp(a['title_romaji']): a['airing']
    for a in ac
}

# Create list of series
anime = []
for info in hb['library_entries']:
    info.update(by_id[info['anime_id']])
    # For currently airing shows, pull in next episode info
    info.update(airing.get(to_cmp(info['romaji_title']), {}))
    anime.append(info)
anime.sort(key=lambda i: i['canonical_title'])

# Print info
print
for a in anime:
    title = a['canonical_title']
    cur = a['episodes_watched']
    total = a['episode_count']

    try:
        available = a['next_episode'] - 1
    except KeyError:
        available = total

    # Only bother if we haven't finished the series
    if cur < total:
        # If we're waiting for next episode
        if cur == available:
            # Create human-readable countdown
            try:
                time = naturaltime(
                    datetime.now() + timedelta(seconds=a['countdown'])
                ).replace(
                    ' from now', ''
                ).replace(
                    'hours', 'hrs'
                ).replace(
                    'minutes', 'mins'
                ).replace(
                    'seconds', 'secs'
                )
            # Unknown time
            except KeyError:
                time = 'UNKNOWN'
            status = green(time)
        # If we're behind
        elif cur < available:
            status = yellow('{}/{}'.format(cur, available))
        # Invalid state
        else:
            status = red('INVALID')
    # We need to mark this as complete
    else:
        status = red('COMPLTE')

    # Status must be colored to be padded correctly
    print("[{:>16}] {}".format(status, title))
print
