#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK

"""
Uses the (unstable) kitsu.io API and (undocumented) anichart.net API to tell
you what episodes you need to catch up on. You can specify the username either
via argument or the ANICHK_USERNAME environment variable.
"""

import re
import json
from sys import exit
from os import environ
from subprocess import check_output
from datetime import datetime, timedelta
from humanize import naturaltime
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from argcomplete import autocomplete

# Constants and helpers
KT_USER = 'https://kitsu.io/api/edge/users?filter\[name\]={}'
KT_LIB = ('https://kitsu.io/api/edge/library-entries?'
          'page\[limit\]=1000000&'
          'include=media&'
          'filter\[status\]=current&'
          'filter\[mediaType\]=Anime&'
          'filter\[userId\]={}')
AC_URL = 'http://anichart.net/api/chart/airing'
END = '\033[0m'
LONG_VOWELS = re.compile(r'([aeiou])\1+')


def normalize(s):
    return LONG_VOWELS.sub(r'\1', ''.join(c.lower() for c in s if c.isalnum()))


def red(s):
    return '\033[31m{}{}'.format(s, END)


def green(s):
    return '\033[32m{}{}'.format(s, END)


def yellow(s):
    return '\033[33m{}{}'.format(s, END)


def exit_with(s):
    print('{}\n'.format(red(s)))
    exit(1)


# Parse args
parser = ArgumentParser(description=__doc__,
                        formatter_class=RawDescriptionHelpFormatter)
parser.add_argument('--porcelain',
                    help="only output unwatched as [series] [episode #]",
                    action='store_true')
parser.add_argument('username',
                    help="kitsu.io username",
                    nargs='?',
                    type=str,
                    default=environ.get('ANICHK_USERNAME'))
autocomplete(parser)
args = parser.parse_args()
porcelain = args.porcelain
username = args.username

if not username:
    exit_with("No username provided.")


# Printing functions
def human(s=''):
    if not porcelain:
        print(s.encode('UTF-8'))


def machine(s=''):
    if porcelain:
        print(s.encode('UTF-8'))


# curl is more consistent than requests.get...
def curl(url):
    return json.loads(check_output(['curl', '-sf', url]))


# Get user ID
human('Fetching kitsu.io profile for {}...'.format(username))
try:
    uid = curl(KT_USER.format(username))['data'][0]['id']
except OSError:
    exit_with("Could not reach kitsu.io.")
except ValueError:
    exit_with("{} isn't on kitsu.io.".format(username))

# Get your currently watching anime
human('Fetching library entries for user id {}...'.format(uid))

kt = curl(KT_LIB.format(uid))

if not kt['data']:
    exit_with("{} isn't watching anything.".format(username))

by_id = {
    a['id']: a['attributes']
    for a in kt['included']
}

# Get currently airing anime
human('Fetching currently airing series from anichart.net...')
try:
    ac = curl(AC_URL)
except OSError:
    exit_with("Could not reach anichart.net.")
except ValueError:
    exit_with("Malformed anichart.net JSON.")

airing = {}
for a in ac:
    airing[normalize(a['title_romaji'])] = a['airing']
    # Sometimes kitsu.io will put english for romaji...
    airing[normalize(a['title_eng'])] = a['airing']

# Create list of series
anime = []
for info in kt['data']:
    attrs = info['attributes']
    attrs.update(by_id[info['relationships']['media']['data']['id']])
    # For currently airing shows, pull in next episode attrs
    attrs.update(airing.get(normalize(attrs['titles']['en_jp']), {}))
    anime.append(attrs)
anime.sort(key=lambda i: i['canonicalTitle'])

# Print info
human()
now = datetime.now()
for a in anime:
    title = a['canonicalTitle']
    cur = a['progress']
    total = a['episodeCount']

    try:
        available = a['next_episode'] - 1
    except KeyError:
        available = total

    # Only bother if we haven't finished the series
    if not total or cur < total:
        # If we're waiting for next episode
        if cur == available:
            # Create human-readable countdown
            try:
                time = naturaltime(
                    now + timedelta(seconds=a['countdown'])
                ).replace(
                    ' from now', ''
                ).replace(
                    'hour', 'hr'
                ).replace(
                    'minute', 'min'
                ).replace(
                    'second', 'sec'
                )
            # Unknown time
            except KeyError:
                time = 'UNKNOWN'
            status = green(time)
        # If we're behind
        elif cur < available:
            status = yellow('{}/{}'.format(cur, available))
            machine(u'{} {}'.format(title, cur + 1))
        # If no information available
        elif not available:
            status = yellow('NO INFO')
        # Invalid state
        else:
            status = red('INVALID')
    # We need to mark this as complete
    else:
        status = red('COMPLTE')

    # Status must be colored to be padded correctly
    human(u'{:>16} {}'.format(status, title))
human()
